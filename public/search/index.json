[{"content":"After spending a good deal of time working in depth with User Defined Types at the end of 2023, I want to expand my previous post on the basics of User Defined Types. User Defined Types provide a great new capability as we write Bicep code; it is also a feature that is hard to define it\u0026rsquo;s value until you see it in action. In this post I will walk through a Bicep template I designed to help deploy Azure SQL Databases. This template takes advantage of multiple advanced features and techniques that will bring better understanding and speed to your deployments.\nTemplate Scope overview Before diving into the Bicep template, I want to explain the design of our Bicep deployment. There are 2 components to our strategy, modules and templates.\nModules - Generalized resource that contain the logic to successfully deploy the resource Templates - Contain the business and security requirements for a deployment Modules are generalized Bicep files that target an Azure resource (e.g Azure SQL, Azure Virtual Machine, Virtual Network). These modules are designed to allow for deployment in multiple configurations without altering the module. These are based on the Azure Resource Modules project. Utilizing a generalized module allows us to abstract away logic and minimize the complexity of the template design by teams.\nHere is an example of logic that would be part of module. The Bicep below checks if the template calling this module has passed any Identity properties.\n1 2 3 4 5 6 var formattedUserAssignedIdentities = reduce(map((managedIdentities.?userAssignedResourcesIds ?? []), (id) =\u0026gt; { \u0026#39;${id}\u0026#39;: {} }), {}, (cur, next) =\u0026gt; union(cur, next)) // Converts the flat array to an object like { \u0026#39;${id1}\u0026#39;: {}, \u0026#39;${id2}\u0026#39;: {} } var identity = !empty(managedIdentities) ? { type: (managedIdentities.?systemAssigned ?? false) ? (!empty(managedIdentities.?userAssignedResourcesIds ?? {}) ? \u0026#39;SystemAssigned,UserAssigned\u0026#39; : \u0026#39;SystemAssigned\u0026#39;) : (!empty(managedIdentities.?userAssignedResourcesIds ?? {}) ? \u0026#39;UserAssigned\u0026#39; : null) userAssignedIdentities: !empty(formattedUserAssignedIdentities) ? formattedUserAssignedIdentities : null } : null This abstraction provides several benefits:\nTemplate designers are not required to develop complex logic to manage parameter and variable input. Template parameters are focused on deployment specific information. Template development speed can be increased. The goal of this strategy is to create templates that require minimal complexity to meet the business requirements for specific deployment scenarios. For example, we have projects that are allowed to host resources with public access, while other projects that have access to on-premise resources are not allowed to have publicly facing resources. The template for public access deployment would have options for public access while the second template would instead require options to ensure traffic is not publicly available.\nHere is snippet of a template that is used to ensure deployments are not publicly available:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 module sqlServer \u0026#39;../../modules/sql/server/main.bicep\u0026#39; = { name: \u0026#39;${sqlServerName}-dp\u0026#39; params: { name: sqlServerName administratorLogin: sqlServerConfiguration.administratorLogin administratorLoginPassword: sqlServerConfiguration.administratorLoginPassword administrators: sqlServerConfiguration.administrators managedIdentities: sqlServerConfiguration.managedIdentitiesType location: location lock: sqlServerConfiguration.?lock ?? null publicNetworkAccess: \u0026#39;Disabled\u0026#39; restrictOutboundNetworkAccess: \u0026#39;Disabled\u0026#39; enableDefaultTelemetry: false minimalTlsVersion: \u0026#39;1.2\u0026#39; Templates can meet security and business requirements by limiting the property options available for the user. With this template a user would not be able to enable public network access through misconfiguration of a parameter file. While it is possible for someone to modify the template directly during a PR, the expectation is that this change will be caught during the PR review. If it was missed during the review, then Azure Policy would block the deployment in our environment. Having layers of validation is crucial to ensuring properly configured resources in your deployments.\nTemplate components Let\u0026rsquo;s review the main components of our template.\nOur template is organized into sections:\nUser Defined Types Parameters Variables Resources Modules Outputs Defining a good structure for your templates can ensure consistent development across multiple teams. Defining structure, formatting, and naming standards allow for faster development and review. I highly recommend developing a style guide for the creation of templates and modules. For this post we will be focusing on the User Defined Types in our template.\nUser Defined Types Our template utilizes several User Defined Types to improve usability and discovery of valid parameter values. These types are imported from several files using the compileTimeImports feature:\n1 2 3 4 5 6 7 import { azureEnvironmentType sqlDatabaseSettingType sqlServerSettingType privateEndpointSubnetType convertGigabytesToBytes } from \u0026#39;./types/types.bicep\u0026#39; User Defined Types can grow to be quite large. We can move our User Defined Types to separate Bicep files that represent different parts of our template logic. To ensure our main template file does not become difficult to navigate, I have broken out the logic into several files. 1 for the core SQL server, database, and deployment specific types, and 3 for the SQL sku options for the SQL Database. We will learn more about those types later in this post. First lets look at the core User Defined Types.\nAzure Environment Type The azureEnvironmentType contains information specific to our environments and deployments. It provides static information that can be used to dynamically create or complete resources. The export() decorator makes the type available for import from another Bicep file. The sealed() decorator prevents modification of the property values to avoid alterations in the parameter file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @description(\u0026#39;Azure environment specific configuration settings\u0026#39;) @export() @sealed() type azureEnvironmentType = { @description(\u0026#39;Azure US Government specific settings\u0026#39;) AzureUSGovernment: { @description(\u0026#39;Azure Gov Event Hub ResourceIds\u0026#39;) eventHubName: { prod: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; qa: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; dev: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; } @description(\u0026#39;Azure Gov supported regions\u0026#39;) region: { usgovvirginia: \u0026#39;ugv\u0026#39; usgovtexas: \u0026#39;ugt\u0026#39; } @description(\u0026#39;Azure Gov Log Analytics ResourceIds\u0026#39;) workspace: { prod:\u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; qa: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; dev: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; } @description(\u0026#39;Azure Global Private DNS Zones\u0026#39;) privateEndpointDns: { sql: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; } }? @description(\u0026#39;Azure Global specific settings\u0026#39;) AzureCloud: { @description(\u0026#39;Azure Global Event Hub ResourceIds\u0026#39;) eventHubName: { prod: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; qa: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; dev: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; } @description(\u0026#39;Azure Global supported regions\u0026#39;) region: { eastus: \u0026#39;eus\u0026#39; westus: \u0026#39;wus\u0026#39; } @description(\u0026#39;Azure Global Log Analytics ResourceIds\u0026#39;) workspace: { prod: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; qa: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; dev: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; } @description(\u0026#39;Azure ECM Global Private DNS Zones\u0026#39;) privateEndpointDns: { #disable-next-line no-hardcoded-env-urls sql: \u0026#39;\u0026lt;resourceId\u0026gt;\u0026#39; } }? } While this information could also be stored in a variable, providing it as a type allows us to add helpful descriptions for consumers of the template. Providing a re-usable type that can be used to retrieve environment static values ensures consistent resource deployments.\nHere is an example of dynamically creating the SQL Server name based on environment and region information found in the azureEnvironmentType:\n1 var sqlServerName = \u0026#39;sql-${projectName}-${deploymentEnvironment}-${azureEnvironment![environment().name].region[location]}\u0026#39; Another example of accessing the private endpoint DNS zone Resource Id found in the hub network subscription:\n1 2 3 4 5 6 7 8 privateEndpoints: [ { subnetResourceId: privateEndpointSubnet.id privateDnsZoneResourceIds: [ azureEnvironment![environment().name].privateEndpointDns.sql ] } ] sqlServerSettingType This Type contains all the parameters needed by our template for the deployment of our SQL Server resource. As I mentioned before, the template focuses on the features of SQL Server for a specific business case. Ensuring each property has a detailed description helps consumers understand the parameter and the potential values available to them. Our goal is to allow consumers to create and complete a new parameter file without reading additional documentation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @export() type sqlServerSettingType = { @description(\u0026#39;Optional. Admin user name for SQl server\u0026#39;) administratorLogin: string? @secure() @description(\u0026#39;Admin Password for SQL Server\u0026#39;) administratorLoginPassword: string? @description( \u0026#39;The Azure Active Directory administrator of the server. This can only be used at server create time. If used for server update, it will be ignored or it will result in an error. For updates individual APIs will need to be used.\u0026#39; ) administrators: { @description(\u0026#39;\\\u0026#39;ActiveDirectory\\\u0026#39; is currently the only Type available\u0026#39;) administratorType: \u0026#39;ActiveDirectory\u0026#39; @description(\u0026#39;Azure Active Directory only Authentication enabled.\u0026#39;) azureADOnlyAuthentication: true | false @description(\u0026#39;Login name of the server administrator.\u0026#39;) login: string @description(\u0026#39;Principal Type of the sever administrator\u0026#39;) principalType: \u0026#39;Application\u0026#39; | \u0026#39;Group\u0026#39; | \u0026#39;User\u0026#39; @description(\u0026#39;SID (object ID) of the server administrator.\u0026#39;) sid: string @description(\u0026#39;Tenant ID of the administrator. AzGov | AzGlobal) tenantId: \u0026#39;AzGovTenantId\u0026#39; | \u0026#39;AzGlobalTenantId\u0026#39; }? lock: lockType managedIdentitiesType: { @description(\u0026#39;Optional. Enables system assigned managed identity on the resource.\u0026#39;) systemAssigned: bool? @description(\u0026#39;Optional. The resource ID(s) to assign to the resource.\u0026#39;) userAssignedResourcesIds: string[]? }? } @export() @description(\u0026#39;Optional. The type of lock to be applied to the resource\u0026#39;) type lockType = { @description(\u0026#39;Optional. Specify the name of lock.\u0026#39;) name: string? @description(\u0026#39;Optional. Specify the type of lock.\u0026#39;) kind: (\u0026#39;CanNotDelete\u0026#39; | \u0026#39;ReadOnly\u0026#39; | \u0026#39;None\u0026#39;)? }? sqlDatabaseSettingType This Type defines all the required properties to successfully deploy databases to the SQL server.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @export() @description(\u0026#39;Configuration settings for SQL Database Deployment\u0026#39;) type sqlDatabaseSettingType = { @description(\u0026#39;The name of the database\u0026#39;) name: string @description(\u0026#39;The name of the SKU, this value is filtered based on the SKU Tier\u0026#39;) skuOptions: sqlDatabaseSkuOptions @description(\u0026#39;The default database collation is SQL_Latin1_General_CP1_CI_AS\u0026#39;) collation: \u0026#39;SQL_Latin1_General_CP1_CI_AS\u0026#39;? @description(\u0026#39;Diagnostic Setting options\u0026#39;) diagnosticSettings: diagnosticSettingType @description(\u0026#39;Optional. Whether or not this database is a ledger database, which means all tables in the database are ledger tables. Note: the value of this property cannot be changed after the database has been created.\u0026#39;) isLedgerOn: bool? @description(\u0026#39;The license type to apply for this database.\u0026#39;) licenseType: string? @description(\u0026#39;Defines the period when the maintenance updates will occur.\u0026#39;) maintenanceConfigurationId: \u0026#39;window_5pm_8am_daily\u0026#39; | \u0026#39;window_10pm_6am_EST_Monday_Thursday\u0026#39; | \u0026#39;windows_10pm_6am_EST_Friday_Sunday\u0026#39; @description(\u0026#39;Optional. The name of the sample schema to apply when creating this database.\u0026#39;) sampleName: string? tags: object? @description(\u0026#39;The Elastic Pools to create with the server.\u0026#39;) elasticPoolId: string? enableDefaultTelemetry: false @description( \u0026#39;Optional. The storage account type to be used to store backups for this database.\u0026#39; ) requestedBackupStorageRedundancy: \u0026#39;Local\u0026#39; | \u0026#39;Zone\u0026#39; | \u0026#39;\u0026#39; @description(\u0026#39;Optional. The short term backup retention policy to create for the database.\u0026#39;) backupShortTermRetentionPolicy: object? @description(\u0026#39;Optional. The long term backup retention policy to create for the database.\u0026#39;) backupLongTermRetentionPolicy: object? @description(\u0026#39;\u0026#39;\u0026#39; Specifies the mode of database creation. Default: regular database creation. Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database. Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database. PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified. Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore. Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database\u0026#39;s original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time. RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID. Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.\u0026#39; \u0026#39;\u0026#39;\u0026#39;) createMode: \u0026#39;Default\u0026#39; @description(\u0026#39;The resource identifier of the source database associated with create operation of this database.\u0026#39;) sourceDatabaseResourceId: string? @description(\u0026#39;Specifies the time that the database was deleted.\u0026#39;) sourceDatabaseDeletionDate: string? @description(\u0026#39;The resource identifier of the recovery point associated with create operation of this database.\u0026#39;) recoveryServicesRecoveryPointResourceId: string? @description(\u0026#39;Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.\u0026#39;) restorePointInTime: string? }[] Again good descriptions and simplified options are a great benefit to the consumers of the template. A good example of this is the maintenanceConfigurationId property. The value required by the SQL resource is unique resource Id per region (\u0026lsquo;Microsoft.Maintenance/publicMaintenanceConfigurations/SQL_eastus_DB_1\u0026rsquo;). The resourceId does not provide meaningful information for the user to determine what value they should choose. To assist the user, we provide them more descriptive options by having them select the name of the maintenance windows that each resourceId represents.\n1 2 @description(\u0026#39;Defines the period when the maintenance updates will occur.\u0026#39;) maintenanceConfigurationId: \u0026#39;window_5pm_8am_daily\u0026#39; | \u0026#39;window_10pm_6am_EST_Monday_Thursday\u0026#39; | \u0026#39;windows_10pm_6am_EST_Friday_Sunday\u0026#39; In the template, the maintenance window names and resource Ids are part of variable object.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var maintenanceConfigurationId = { window_5pm_8am_daily: subscriptionResourceId( \u0026#39;Microsoft.Maintenance/publicMaintenanceConfigurations\u0026#39;, \u0026#39;SQL_Default\u0026#39; ) window_10pm_6am_EST_Monday_Thursday: subscriptionResourceId( \u0026#39;Microsoft.Maintenance/publicMaintenanceConfigurations\u0026#39;, \u0026#39;SQL_${location}_DB_1\u0026#39; ) window_10pm_6am_EST_Friday_Sunday: subscriptionResourceId( \u0026#39;Microsoft.Maintenance/publicMaintenanceConfigurations\u0026#39;, \u0026#39;SQL_${location}_DB_1\u0026#39; ) } We can then pass the proper value for the maintenance window using the variable and parameter value provided by the user.\n1 maintenanceConfigurationId[database.maintenanceConfigurationId] Providing descriptive and meaningful options will minimize questions and confusion when using your template!\nsqlDatabaseSkuOptions Now we get into the complex portion of our template. This type was designed to help dynamically provide users the required properties based on the chosen sku for SQL Database. Generally you provide sku information for SQL Databases through properties such as:\nskuName skuSize skuCapacity skuFamily These values align with various tiers of Azure SQL DB:\nDTU Basic Standard Premium vCore General Purpose Provisioned General Purpose Serverless Each of these tiers has multiple sku\u0026rsquo;s and potentially different features based on your sku choice. Previously, there was no way to organize the potential options due to the complexity and quantity of sku\u0026rsquo;s available. However, with User Defined Types and discriminated unions, we can bring structure to the chaotic assortment of sku\u0026rsquo;s and properties.\nBelow is the top level User Defined Type, sqlDatabaseSkuOptions used in the sqlDatabaseSettingType to determine what properties are required for a SQL Database based on the sku chosen.\n1 2 3 4 5 6 7 8 9 import { sqlDatabaseSkuBasic, sqlDatabaseSkuStandard, sqlDatabaseSkuPremium } from \u0026#39;DtuType.bicep\u0026#39; import { sqlDatabaseSkuGeneralPurposeProvisioned } from \u0026#39;generalPurposeProvisionedType.bicep\u0026#39; import { sqlDatabaseSkuGeneralPurposeServerless} from \u0026#39;generalPurposeServerlessType.bicep\u0026#39; // SQL SKUs Type @sealed() @discriminator(\u0026#39;type\u0026#39;) type sqlDatabaseSkuOptions = sqlDatabaseSkuBasic | sqlDatabaseSkuStandard | sqlDatabaseSkuPremium | sqlDatabaseSkuGeneralPurposeProvisioned | sqlDatabaseSkuGeneralPurposeServerless While this type appears simple, there is a great deal of logic and configuration hidden under the covers. The sqlDatabaseSkuOptions type is a composition of 5 User Defined Types:\nsqlDatabaseSkuBasic sqlDatabaseSkuStandard sqlDatabaseSkuPremium sqlDatabaseSkuGeneralPurposeProvisioned sqlDatabaseSkuGeneralPurposeServerless This is accomplished using the @discriminator() decorator. User Defined Types can be combined using a common property found in each type. From the Bicep documentation:\nThe discriminator decorator takes a single parameter, which represents a shared property name among all union members. This property name must be a required string literal on all members and is case-sensitive. The values of the discriminated property on the union members must be unique in a case-insensitive manner.\nEach of our 5 sku types above have a type property that is unique to that sku. This is the first filter used to to choose our sku. Let\u0026rsquo;s take a look at at the sqlDatabaseSkuStandard type:\n1 2 3 4 5 6 7 @export() type sqlDatabaseSkuStandard = { type: \u0026#39;Standard\u0026#39; skuTier: \u0026#39;Standard\u0026#39; @description(\u0026#39;The Standard SKU of the SQL Server you want to deploy.\u0026#39;) sku: standardDtuType } For most SQL Database sku\u0026rsquo;s, there are 2 required properties, skuTier and skuName. For all standard sku\u0026rsquo;s, the skuTier value is Standard. The SkuName has 9 options available, one for each (Standard Service Tier). Along with skuName, there is also a databaseMaxSize property that is needed for each standard sku with. To further complicate our decision, skus can have different maximum database sizes. So how do we handle all these sku options? Discriminated Unions to the rescue! We use dtu property as the key for the standardDtuType discriminated type:\n1 2 3 4 // Unioned Type for Standard Skus @discriminator(\u0026#39;dtu\u0026#39;) type standardDtuType = standardDTU10 | standardDTU20 | standardDTU50 | standardDTU100 | standardDTU200 | standardDTU400 | standardDTU800 | standardDTU1600 | standardDTU3000 Each sku has different capacities such as DTU (Database Transaction Unit) and potential database sizes. Below is one of the sku types used in the standardDtuType:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type standardDTU10 = { @description(\u0026#39;database transaction unit (DTU)\u0026#39;) dtu: \u0026#39;10\u0026#39; @description( \u0026#39;NOTE: Standard S0, S1 and S2 tiers provide less than one vCore (CPU). For resource-intensive workloads, a service tier of S3 or greater is recommended. \u0026#39; ) skuName: \u0026#39;S0\u0026#39; @maxValue(250) @minValue(1) @description( \u0026#39;Max size for 10 DTUs is 250 GB. Data Storage for S0 uses HDD based storage media best suited for development and testing.\u0026#39; ) databaseMaxSize: 1 | 2 | 5 | 10 | 20 | 30 | 40 | 50 | 100 | 150 | 200 | 250 } The dtu property is used as the discriminated property in our standardDtuType to combine all of our standard sku options. dtu was chosen as it best represented the deciding factor most consumers would use, the performance level of the sku. The dtu value is used as friendly type to help provide the user with a better understanding of the sku options. The skuName property is the actual value passed to our SQL module to choose the correct sku. DatabaseMaxSize is the value passed for the storage capacity of the sku. Standard sku\u0026rsquo;s also include specific step increases for the database size. By providing the user with this information from our template, choosing a sku results in all the required parameters being present. Here is an example of the intellisense provided in a Bicep parameter file using our SQL template. The user is provided meaningful information to determine what sku and required properties are needed for their deployment without needing to leave the parameter file.\nWhile this improves the user experience for database sku selection, there some considerations with this approach.\nPros\nUsers have convenient access to most required properties to choose a sku. Only valid options are presented to the user. Option values that are sku specific are only displayed for the appropriate sku. Cons:\nSku\u0026rsquo;s availability is region specific, some sku\u0026rsquo;s may not be available in all regions. Testing all sku options can be difficult to automate as part of a CI/CD pipeline. For more complex or unique DB deployments, additional guidance may still be needed for Azure Documentation. Let\u0026rsquo;s map out our design so far! Our sqlDatabaseSkuOptions type contains the sku tiers defined in 5 types. Each sku tier type contains all the available skus for that tier. Those individual skus will then contain the required properties for deploying that sku.\nThis strategy, while complex, provides a huge benefit to consumers of our template. Ensuring users can only choose the required and valid options for their sku increases the success of our template deployment. There is no need to go read additional documentation or question which properties are needed for your chosen sku. By dividing the SQL Database sku tier\u0026rsquo;s into User Defined Types, we are able to create nested types that contain the sku specific options that are only presented when the user decides.\nTo drive the point home, lets look at the GeneralPurposeProvisioned Type:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @export() type sqlDatabaseSkuGeneralPurposeProvisioned = { type: \u0026#39;GeneralPurposeProvisioned\u0026#39; skuTier: \u0026#39;GeneralPurpose\u0026#39; @description( \u0026#39;The General Purpose Provisioned Tier of the SQL Server you want to deploy.\u0026#39; ) sku: generalPurposeProvisionedType } @discriminator(\u0026#39;vCores\u0026#39;) type generalPurposeProvisionedType = GP_Gen5_2 | GP_Gen5_4 | GP_Gen5_6 | GP_Gen5_8 | GP_Gen5_10 | GP_Gen5_12 | GP_Gen5_14 | GP_Gen5_16 | GP_Gen5_18 | GP_Gen5_20 | GP_Gen5_24 | GP_Gen5_32 | GP_Gen5_40 | GP_Gen5_80 @sealed() type GP_Gen5_2 = { @description(\u0026#39;General Purpose Provisioned Tier SKU Name\u0026#39;) skuName: \u0026#39;GP_Gen5_2\u0026#39; @maxValue(1024) @minValue(1) @description(\u0026#39;Max data storage size is 1024 GB\u0026#39;) databaseMaxSize: int @description(\u0026#39;2 vCores assigned with SKU GP_Gen5_2 \u0026#39;) vCores: \u0026#39;2\u0026#39; } Instead of using dtu, the generalPurposeProvisionedType discriminated union uses vCores for it\u0026rsquo;s joining type. This helps the user in deciding which sku to choose based on the performance needed for their deployment (vCores being one of the biggest factors). Each sku type has 3 properties:\nskuName databaseMaxSize vCores Both skuName and databaseMaxSize are needed for the deployment of the SQL DB, whereas vCores is only used to provide a user readable convention for choosing the sku they need. GP_Gen5_2, while being the required value for deployment, does not provide a good description for most users. You can also see in this case that the GP_Gen5_2 sku allows any value for databaseMaxSize instead of set size limits like the Standard sku we looked at previously. Each User Defined Type for each sku tier is slightly different to handle the specific requirements of that tier. Please continue to investigate the template on my GitHub to see the different configurations of the other SQL sku tiers.\nConclusion User Defined Types represent a major change in how we can author Bicep templates and modules. Having the ability to create complex logical types to provide our template easy to digest parameters is a huge win. Removing some of the guesswork and confusing parameter requirements from our template and module deployments will go a long way in increasing user adoption. I hope this post has helped you understand the potential of this new feature. Happy Coding!\n","date":"2024-01-08T13:38:20.061Z","permalink":"http://localhost:1313/p/user-defined-types-action/","title":"User Defined Types in Action"},{"content":"Earlier this year Microsoft released version 2.0 of the AzApi Terraform provider. My favorite feature of this release was the implementation of Dynamic Properties, no more Json Encoding and Decoding! Removing the requirement for JSON formatting in favor of HCL (HashiCorp Configuration Language) was the final push I needed to start module development with AzAPI. Unlike the AzureRM provider, AzAPI resource templates are found on Microsoft Learn. AzAPI resource formats are different than those used by AzureRM as shown below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #AzAPI resource \u0026#34;azapi_resource\u0026#34; \u0026#34;symbolicname\u0026#34; { type = \u0026#34;Microsoft.Resources/resourceGroups@2024-11-01\u0026#34; name = \u0026#34;string\u0026#34; location = \u0026#34;string\u0026#34; managedBy = \u0026#34;string\u0026#34; tags = { {customized property} = \u0026#34;string\u0026#34; } body = { properties = { } } } #AzureRM resource \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;example\u0026#34; { name = \u0026#34;example\u0026#34; location = \u0026#34;West Europe\u0026#34; } The differences between the provider can be quite intimidating if you are used AzureRM exclusively. To help ease the transition to AzAPI, we turn on a slick tool called newres. Newres is a command-line tool that provides the ability to create boilerplate module resources for several Terraform providers. Recently newres has been updated to allow the generation of resources for the AzAPI provider.\nAzureRM Resource Creation with Newres Newres makes it easy to generate boilerplate code when starting your module development. The command below will generate the following main.tf and variables.tf file for the deployment on an Azure Resource Group.\n1 newres -dir ./ -r azurerm_resource_group 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #Main.tf resource \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;this\u0026#34; { location = var.resource_group_location name = var.resource_group_name tags = var.resource_group_tags dynamic \u0026#34;timeouts\u0026#34; { for_each = var.resource_group_timeouts == null ? [] : var.resource_group_timeouts content { create = timeouts.value.create delete = timeouts.value.delete read = timeouts.value.read update = timeouts.value.update } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #Variables.tf variable \u0026#34;resource_group_location\u0026#34; { type = string description = \u0026#34;(Required) The Azure Region where the Resource Group should exist. Changing this forces a new Resource Group to be created.\u0026#34; nullable = false } variable \u0026#34;resource_group_name\u0026#34; { type = string description = \u0026#34;(Required) The Name which should be used for this Resource Group. Changing this forces a new Resource Group to be created.\u0026#34; nullable = false } variable \u0026#34;resource_group_tags\u0026#34; { type = map(string) default = null description = \u0026#34;(Optional) A mapping of tags which should be assigned to the Resource Group.\u0026#34; } variable \u0026#34;resource_group_timeouts\u0026#34; { type = object({ create = optional(string) delete = optional(string) read = optional(string) update = optional(string) }) default = null description = \u0026lt;\u0026lt;-EOT - `create` - (Defaults to 1 hour and 30 minutes) Used when creating the Resource Group. - `delete` - (Defaults to 1 hour and 30 minutes) Used when deleting the Resource Group. - `read` - (Defaults to 5 minutes) Used when retrieving the Resource Group. - `update` - (Defaults to 1 hour and 30 minutes) Used when updating the Resource Group. EOT } This code generation saves a considerable amount of time during initial module development. This time saving allows developers to focus more on the specific customizations required to meet their environment security and compliance requirements. For the development of a complex module, this can be a significant time savings.\nAzAPI Resource Generation with Newres Baseline AzApi resource generation can now be done with a simple command to newres.\n1 newres --azapi-resource-type \u0026#34;Microsoft.Resources/resourceGroups@2021-04-01\u0026#34; -r azapi_resource --dir . This will generate the require main.tf and variables.tf for the resource provided.\nmain.tf\n1 2 3 4 5 6 7 8 resource \u0026#34;azapi_resource\u0026#34; \u0026#34;this\u0026#34; { type = \u0026#34;Microsoft.Resources/resourceGroups@2021-04-01\u0026#34; body = var.resource_body location = var.resource_location name = var.resource_name parent_id = var.resource_parent_id tags = var.resource_tags } Variables.tf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 variable \u0026#34;resource_body\u0026#34; { type = object({ managedBy = optional(string) }) description = \u0026lt;\u0026lt;-EOT - `managedBy` - --- `properties` block supports the following: EOT nullable = false } variable \u0026#34;resource_location\u0026#34; { type = stringhttps://www.bing.com/ck/a?!\u0026amp;\u0026amp;p=a51fc3e7a50e6b8f30ff9ae9e13d8458f17711626ca396bd655755ff6a557498JmltdHM9MTczNTYwMzIwMA\u0026amp;ptn=3\u0026amp;ver=2\u0026amp;hsh=4\u0026amp;fclid=29395f82-9cea-661a-2925-4c6b9d1a6749\u0026amp;psq=backup+movies+with+mkv\u0026amp;u=a1aHR0cHM6Ly93d3cuaG93dG9nZWVrLmNvbS8xNjE0OTgvaG93LXRvLWJhY2t1cC15b3VyLWR2ZC1hbmQtYmx1LXJheS1tb3ZpZS1jb2xsZWN0aW9uLw\u0026amp;ntb=1 description = \u0026#34;The location of the resource group. It cannot be changed after the resource group has been created. It must be one of the supported Azure locations.\u0026#34; nullable = false } variable \u0026#34;resource_name\u0026#34; { type = string description = \u0026#34;The resource name\u0026#34; nullable = false } variable \u0026#34;resource_parent_id\u0026#34; { type = string description = \u0026#34;The ID of the azure resource in which this resource is created.\u0026#34; nullable = false } variable \u0026#34;resource_tags\u0026#34; { type = map(string) default = null description = \u0026#34;The tags attached to the resource group.\u0026#34; } Caveats When Using Newres Conclusion Support for AzApi resource modules with newres enables our team to investigate the replacement of our azureRM based modules knowing we will continue to have the same development speed and experience we have come to rely on for module creation. It is a difficult task to ask your team to try and develop new resource modules with the tools that introduce time savings to the process. Immediately there is an natural opposition to a process that feels slower and more time consuming then your current process. Even if the results provide additional benefits, the adoption of that process will be slow and difficult.\n","date":"2023-10-20T13:57:01.161Z","permalink":"http://localhost:1313/p/accelerating-azpai-adoption-with-newres/","title":"Accelerating AzApi Adoption with Newres"},{"content":"User Defined Types in Bicep The Bicep team continues to deliver new features and functionality with each release of Bicep. Many of these new features are first released in an experimental state to allow customers to begin testing and provide feedback early in the development process. User-Defined Types are a feature I have been looking forward to for a long time. As of a recent release of Bicep v0.21.1, this feature is now generally available!\nWhat are User-defined Types User-Define Types are a type statement that allows us to define custom types in our templates. They are defined in a similar way as parameters:\n1 2 3 4 5 // parameter param \u0026lt;parameter-name\u0026gt; \u0026lt;parameter-data-type\u0026gt; = \u0026lt;default-value\u0026gt; //user define type type \u0026lt;user-defined-data-type-name\u0026gt; = \u0026lt;type-expression\u0026gt; In past versions of Bicep you were limited to supported data types for parameters (string, integer, boolean, arrays, objects). We can now create custom types to better describe the parameters needed for the deployment. User-Defined types only use the primitive literal types (string, integer, boolean). The real power is how you combine these these to create your custom types.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // A string type array type stringArray1 = string[] // a string with 3 valid options type stringEnvironments = \u0026#39;dev\u0026#39; | \u0026#39;qa\u0026#39; | \u0026#39;prod\u0026#39; // A type can use other user-defined types, Here we combine the previous types into 1 type parameterObject = { @description(\u0026#39;We can also use *some* decorators on our types.\u0026#39;) stringArray: stringArray1? //adding a ? makes the property optional when using this type @description(\u0026#39;We can also use *some* decorators on our types\u0026#39;) environments: stringEnvironments } param parameterObject parameterObject Using the User-Define Type provides additional intellisense for that type and any other types that were used in that type. .\nWhy am I excited about this feature? Writing complex objects or arrays in Bicep today is like a guessing game. I can require or use values or properties in parts of the template and if these are not documented properly, it increases the difficulty for others using that template. Having to hunt through a Bicep template or readme to find out what values are required in an array or an object can be a blocker to adoption of your template by other teammates. Bicep is amazingly good at providing helpful intellisense to avoid this kind of context switching. The major gap had always been parameter objects and arrays. Let\u0026rsquo;s look at how User-Define Types fill this gap.\nExamples Let\u0026rsquo;s start with a simple template for creating tags for a subscription. Every subscription should have a set of tags that are required for various teams and compliance reasons. Here is a sample of what the required parameters looked like before user-defined types:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Here is a set of parameters needed to get our required tags @description(\u0026#39;Required. Environment for deployed resources\u0026#39;) @allowed([\u0026#39;dev\u0026#39;, \u0026#39;qa\u0026#39;, \u0026#39;prod\u0026#39;]) param environmentTag string @description(\u0026#39;Required. Project Number for subscription\u0026#39;) param projectNumberTag string @description(\u0026#39;Required. Are backups required for this subscription\u0026#39;) @allowed([\u0026#39;True\u0026#39;, \u0026#39;False\u0026#39;]) param backupRequiredTag string @description(\u0026#39;Optional. backup retention options\u0026#39;) @allowed([\u0026#39;\u0026#39;, \u0026#39;1-Week\u0026#39;, \u0026#39;2-Week\u0026#39;, \u0026#39;1-Month\u0026#39;, \u0026#39;2-Month\u0026#39;, \u0026#39;1-Year\u0026#39;]) param backupRetentionTag string @description(\u0026#39;Optional. What day for backups to run\u0026#39;) @allowed([\u0026#39;\u0026#39;, \u0026#39;Monday\u0026#39;, \u0026#39;Tuesday\u0026#39;, \u0026#39;Wednesday\u0026#39;, \u0026#39;Thursday\u0026#39;, \u0026#39;Friday\u0026#39;, \u0026#39;Saturday\u0026#39;, \u0026#39;Sunday\u0026#39;]) param backupWindowTag string @description(\u0026#39;Optional. Any additional tags required for this subscription\u0026#39;) param additionalTags object = {} var requiredSubscriptionTags = { environment: environmentTag projectNumber: projectNumberTag backupRequired: backupRequiredTag backupRetention: backupRetentionTag backupWindow: backupWindowTag } var allsubscriptionTags = union(requiredSubscriptionTags, additionalTags) From a parameter file, I would need to define all 6 parameters and values. With User-Defined Types we now have more flexibility to define our objects directly.\nHere is a User-Define Type alternative:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type subscriptionTagValues = { @description(\u0026#39;Required. Environment for deployed resources\u0026#39;) environment: \u0026#39;dev\u0026#39;| \u0026#39;qa\u0026#39; | \u0026#39;prod\u0026#39; @description(\u0026#39;Required. Project Number for subscription\u0026#39;) projectNumber: string @description(\u0026#39;Required. Are backups required for this subscription\u0026#39;) backupRequired: \u0026#39;True\u0026#39; | \u0026#39;False\u0026#39; @description(\u0026#39;Optional. backup retention options\u0026#39;) backupRetentiond: \u0026#39;\u0026#39;|\u0026#39;1-Week\u0026#39;|\u0026#39;2-Week\u0026#39;|\u0026#39;1-Month\u0026#39;|\u0026#39;2-Month\u0026#39;|\u0026#39;1-Year\u0026#39; @description(\u0026#39;Optional. What day for backups to run\u0026#39;) backupWindow: \u0026#39;\u0026#39;|\u0026#39;Monday\u0026#39;|\u0026#39;Tuesday\u0026#39;|\u0026#39;Wednesday\u0026#39;|\u0026#39;Thursday\u0026#39;|\u0026#39;Friday\u0026#39;|\u0026#39;Saturday\u0026#39;|\u0026#39;Sunday\u0026#39; *:string } param subscriptionTags subscriptionTagValues The Tag Object contains all of our required tags and all the required values and a description of the type property. From our parameter file we get the same intellisense but with a simplified definition of our tag parameter . An additional benefit of this approach is the ability to add tags that are not defined in the object! The final line of the object, *:string, allows the object to take additional undefined properties of the type string. At time of writing, you can only add one type (string, int, boolean) for additional properties at a time. This further simplifies our template parameters by removing additional steps.\nConclusion User-Define Types help to simplify writing templates by giving us the power to define and document complex parameter objects. No one enjoys having to reverse engineer a template just to implement it. Removing that additional uncertainty of confusion bring template re-usability to the next level. Giving teams the ability to define and describe template parameters without needing to write additional documentation will drive adoption with teammates and co-workers.\n","date":"2023-10-20T13:57:01.161Z","permalink":"http://localhost:1313/p/working-user-defined-types-bicep/","title":"Working with User-Defined Types in Bicep"}]